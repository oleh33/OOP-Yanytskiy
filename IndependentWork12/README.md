# Самостійна робота №12  
## Тема: PLINQ — дослідження продуктивності та безпеки

### Мета
Дослідити переваги та недоліки **PLINQ (Parallel LINQ)** у порівнянні зі звичайним LINQ, виміряти продуктивність на великих обсягах даних та розглянути потенційні проблеми безпеки при паралельній обробці.

### Опис реалізації (Program.cs)

#### 1. Перформанс-тести LINQ vs PLINQ

- Створюються колекції `List<int>` з розмірами:
  - 1 000 000 елементів
  - 5 000 000 елементів
  - 10 000 000 елементів
- Кожен елемент — випадкове число з діапазону `[1; 1_000_000]`.
- Для кожної колекції виконується одна й та сама обчислювально інтенсивна операція:

```csharp
.Where(IsPrime)       // перевірка числа на простоту
.Select(n => Math.Sqrt(n))
.ToList();
```

- Варіант 1: звичайний LINQ  
- Варіант 2: PLINQ — `data.AsParallel().Where(...).Select(...).ToList()`  
- Час виконання вимірюється за допомогою `Stopwatch`.

**Очікування / аналіз:**
- Для великих колекцій (5M, 10M) і "важкої" функції `IsPrime` PLINQ зазвичай показує кращий час, оскільки робота паралелізується між ядрами процесора.
- Для менших колекцій виграш може бути відсутнім через накладні витрати на планування потоків і збирання результатів.

#### 2. Побічні ефекти і потокобезпека в PLINQ

Сценарій:

- Маємо колекцію `1_000_000` елементів.
- У першому прикладі виконується:

```csharp
int sum = 0;
data.AsParallel().ForAll(x => sum++);
```

- Очікуване значення `sum` — 1 000 000, але фактичне — менше, тому що декілька потоків одночасно змінюють спільну змінну без синхронізації (race condition).

**Виправлення:**

- Використано потокобезпечну операцію:

```csharp
int sum = 0;
data.AsParallel().ForAll(x => Interlocked.Increment(ref sum));
```

- Після цього `sum` завжди дорівнює кількості елементів.


### Висновки

1. **PLINQ** може давати суттєвий приріст продуктивності на великих колекціях та важких обчисленнях, але для малих обсягів даних звичайний LINQ може бути не гіршим через відсутність накладних витрат.
2. При використанні PLINQ дуже важливо уникати **побічних ефектів** у лямбда-виразах і не змінювати спільні змінні без синхронізації.
3. Для агрегування результатів краще використовувати потікобезпечні механізми (наприклад, `Interlocked`, `lock`, агрегуючі оператори PLINQ), а не "ручні" зміни зовнішнього стану.
4. PLINQ — потужний інструмент, але його застосування має бути **усвідомленим**: він не завжди швидший, і неправильне використання може привести до дуже підступних багів.

### Структура проєкту

- `IndependentWork12.csproj` — налаштування консольного застосунку (.NET 10.0).
- `Program.cs` — код експериментів та коментарі-звіт.
- `README.md` — короткий текстовий звіт для здачі.
